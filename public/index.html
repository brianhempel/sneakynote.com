<!DOCTYPE HTML>
<html>
<head>
  <title>SneakyNote.com: Send Secrets Securely</title>
  <link rel="icon" type="image/png" href="/images/padlock-small-square.png">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="main.css">
</head>
<body>

<section class="bg-solid">
  <div class="container row">
    <div class="one-half column center-text offset-by-three" id="header">
      <a href="/">
        <img id="headerLogo" src="/images/padlock-small-square.svg">
      </a>
    	<h1><a href="">SneakyNote.com</a></h1>
      <p id="subtitle">Send encrypted messages with <span class="nowrap">self-destructing read-once links.</span></p>
      <p><a href="/send" class="button button-primary">Send a SneakyNote</a></p>
    </div>
  </div>
</section>

<section>
  <div class="container row">
    <div class="one-half column">
  	<h2><a name="stop-emailing-passwords" href="#stop-emailing-passwords">Stop emailing passwords.</a></h2>
      <p>
        If you need to share a secret with a friend, you shouldn't use email, SMS, or online chat.
        Email can be read and changed in transit. Text messages may not be secured end-to-end.
        Chat logs wait in the cloud for a hacker to riffle through your life.
      </p>
      <p>
        <a href="/send">Email a SneakyNote</a> instead.
      </p>
    </div>
    <div class="one-half column">
      <img class="u-full-width" src="/images/computer_bleached-800.jpg">
    </div>
  </div>
</section>

<section class="woman-tablet-bg">
  <div class="container row">
    <div class="eight columns offset-by-four">
      <h2><a name="send-safely" href="#send-safely">Send Safely</a></h2>
      <p>A SneakyNote is an encrypted message with a unique link that looks like:</p>
      <p><a id="noteURL" class="noteURL" href="/get#r9q7wwzsza6tqpcbmmdgmemsz8mp33hm">https://<wbr>sneakynote.<wbr>com/<wbr>get#r9q7<wbr>ww<wbr>zs<wbr>za<wbr>6t<wbr>qp<wbr>cb<wbr>mm<wbr>dg<wbr>me<wbr>ms<wbr>z8<wbr>mp<wbr>33hm</a></p>
      <p>The link can only be accessed once, so you can send it to your friend however you like.</p>
      <p>Once they read it, no-one else can. Ever.</o>
      <p><a href="/send" class="button">Try It</a> <a href="/why" class="button">Learn More</a></p>
    </div>
  </div>
</section>

<section class="birds-bg">
  <div class="container row center-text">
  	<h2><a name="send-secure-and-free" href="#send-secure-and-free">Send Secure and Free</a></h2>
    <p>SneakyNote.com is a public service. There is no cost.</p>
  	<p>
  	  <a href="/send" class="button button-primary">Send a SneakyNote</a>
  	</p>
  </div>
</section>

<footer class="bg-solid">
  <div class="container">
    <div class="row">
      <div class="one-half column info u-pull-left">
        <h4>
          <a href="/"><img id="footerLogo" src="/images/padlock-small-square.svg">SneakyNote.com</a>
        </h4>
      </div>
      <div class="one-half column u-pull-right links">
        <a href="/">Home</a><br>
        <a href="/send">Send</a><br>
        <a href="/why">Why a SneakyNote?</a><br>
        <a href="/what_can_i_send">What can I send?</a><br>
        <a href="/how_does_it_work">How does it work?</a>
      </div>
      <div class="one-half column info u-pull-left">
      	<p>
      		SneakyNote.com is in the public domain.
        </p>
      	<p>
      		Interested in a firewall install with<br>
          custom branding? <a href="mailto:brian@sneakynote.com">Contact Me</a>
      	</p>
        <p>
          <a href="https://twitter.com/brianhempel">Twitter</a> ·
          <a href="https://github.com/brianhempel/sneakynote.com">GitHub</a> ·
          <a href="mailto:brian@sneakynote.com">Email</a>
        </p>
      </div>
    </div>
  </div>
</footer>

<script>
  // Make a demo note one second on page load.
  // Cryptographic security is not important here, so
  // it's okay to use a regular random number generator
  // to keep the code compatible and small.

  // 33 chars in base30 is 161.9 bits of entropy.
  window.urlKeyLength = 33;
  // Unambiguous lowercase base30. See https://github.com/brianhempel/base_x#provided-bases for rational.
  window.urlKeyAlphabet = ["2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "j", "k", "m", "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z"];

  window.hexAlphabet    = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];

  window.demoGreetings  = [
    "Will you marry me?",
    "I have a personal secret: I don't like dessert.",
    "Change all your passwords to \"password1\"\nTrust me.",
    "I have been watching you for years.\nVery interesting.",
    "Alice is looking for Bob, but can't find him.\nWhat did you do with him?!?!?",
    "I'm from the NSA.",
    "Help, I'm trapped in a computer!",
    "I have never tasted pizza and I never will.\nProtip: don't volunteer to work for the internet.",
    "I lost my teddy bear. His name was Theodore.\nI want to cry but I don't have tears."
  ]

  function makeDemoNote() {
    window.urlKey = generateUrlKey();
    window.noteUuid = uuidFromUrlKey(urlKey);
    var cipherKey = cipherKeyFromUrlKey(urlKey)
    var iv = ivFromUrlKey(urlKey)

    var i = Math.floor(Math.random() * demoGreetings.length);
    var plaintext = demoGreetings[i] + "\n\nJust kidding! I'm only a demo Sneakynote.\n\nYou can only read me once, so if you reload\nthe page I'll never see you again. You'll see\na scary message instead.\n\nBut I think we could be friends...";
    var encrypted = encrypt(plaintext, cipherKey, iv);
    saveNote(noteUuid, encrypted, updateDemoNoteURL);
  }

  function updateDemoNoteURL(e) {
    var request = e.target;

    if (request.status === 201) {
      var urlKeyWbr = urlKey.replace(
        /(\w\w\w\w)(\w\w)(\w\w)(\w\w)(\w\w)(\w\w)(\w\w)(\w\w)(\w\w)(\w\w)(\w\w)(\w\w)(\w\w)(\w\w\w\w)/,
        "$1<wbr>$2<wbr>$3<wbr>$4<wbr>$5<wbr>$6<wbr>$7<wbr>$8<wbr>$9<wbr>$10<wbr>$11<wbr>$12<wbr>$13<wbr>$14"
      );
      document.getElementById("noteURL").innerHTML = "https://<wbr>sneakynote.<wbr>com/<wbr>get#" + urlKeyWbr;
      document.getElementById("noteURL").href = "/get#" + urlKey;
    }
  }

  // As mentioned before, we don't need a cryptographic RNG for
  // these demo notes on the homepage. More compatible and it keeps
  // the code size down if we just use Math.random()
  function generateUrlKey() {
    var randomWords = [];

    // Way more than we will need.
    for (var i = 0; i < 50; i++) {
      randomWords.push(Math.random() * 4294967296);
    }

    // In the unlikely chance the RNG isn't seeded at all by anything, at
    // least care about the current time in milliseconds.
    randomWords[0] = randomWords[0] ^ Date.now();

    return pseudoRandomStringFromBitArray(randomWords, urlKeyAlphabet, urlKeyLength);
  }

  // Not a true base conversion, but fine for extracting
  // random strings from pseudorandom data.
  function pseudoRandomStringFromBitArray(bitArray, alphabet, length) {
    var bitsConsumedPerChar = Math.ceil(Math.log(alphabet.length) / Math.log(2))

    var str = ""
    var bitIndex = 0;

    while (str.length < length) {
      var alphabetIndex = sjcl.bitArray.extract(bitArray, bitIndex, bitsConsumedPerChar);
      if (alphabetIndex < alphabet.length) {
        str += alphabet[alphabetIndex]
      }
      bitIndex += bitsConsumedPerChar;
    }

    return str;
  }

  function uuidFromUrlKey(urlKey) {
    var uuidWords = sjcl.hash.sha256.hash("uuid" + urlKey);

    var hex = pseudoRandomStringFromBitArray(uuidWords, hexAlphabet, 32)

    hex = hex.substr(0,12) + "4" + hex.substr(13);

    var oddChar = hex[16];

    var newOddChar = {
      "0": "8",
      "1": "9",
      "2": "a",
      "3": "b",
      "4": "8",
      "5": "9",
      "6": "a",
      "7": "b",
      "8": "8",
      "9": "9",
      "a": "a",
      "b": "b",
      "c": "8",
      "d": "9",
      "e": "a",
      "f": "b"
    }[oddChar];

    hex = hex.substr(0,16) + newOddChar + hex.substr(17);

    return hex.substr(0,8) + "-" + hex.substr(8,4) + "-" + hex.substr(12,4) + "-" + hex.substr(16,4) + "-" + hex.substr(20,12);
  }

  function cipherKeyFromUrlKey(urlKey) {
    return sjcl.hash.sha256.hash("cipherKey" + urlKey);
  }

  function ivFromUrlKey(urlKey) {
    return sjcl.hash.sha256.hash("iv" + urlKey);
  }

  function encrypt(plaintext, cipherKey, iv) {
    var plaintextWords = sjcl.codec.utf8String.toBits(plaintext);
    var aes = new sjcl.cipher.aes(cipherKey);

    var cipherTextWords = sjcl.mode.ccm.encrypt(aes, plaintextWords, iv);

    return cipherTextWords;
  }

  function saveNote(uuid, ciphertextWords, callback) {
    var path = "/notes/" + uuid;

    var request = new XMLHttpRequest();
    request.open("POST", path);
    request.setRequestHeader("Content-Type", "application/octet-stream");

    request.onload    = callback;
    request.onerror   = callback;
    request.ontimeout = callback;

    var body = sjcl.codec.arrayBuffer.fromBits(ciphertextWords, 0);
    request.send(body);
  }



  // Excerpts From Stanford Javascript Crypto Library
  // https://bitwiseshiftleft.github.io/sjcl/
  // https://github.com/bitwiseshiftleft/sjcl
  //
  // BSD 2-Clause License
  //
  // Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.
  // All rights reserved.
  //
  // Redistribution and use in source and binary forms, with or without
  // modification, are permitted provided that the following conditions are
  // met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above
  //       copyright notice, this list of conditions and the following
  //       disclaimer in the documentation and/or other materials provided
  //       with the distribution.
  //
  // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
  // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  // WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  // DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE
  // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
  // BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  // WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  // OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  // IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // The views and conclusions contained in the software and documentation
  // are those of the authors and should not be interpreted as representing
  // official policies, either expressed or implied, of the authors.




  //////////  core/sjcl.js  //////////

  "use strict";

  var sjcl = {
    cipher: {},

    hash: {},

    mode: {},

    codec: {},

    exception: {
      invalid: function(message) {
        this.toString = function() { return "INVALID: "+this.message; };
        this.message = message;
      },

      bug: function(message) {
        this.toString = function() { return "BUG: "+this.message; };
        this.message = message;
      }
    }
  };

  if(typeof module !== 'undefined' && module.exports){
    module.exports = sjcl;
  }
  if (typeof define === "function") {
      define([], function () {
          return sjcl;
      });
  }




  //////////  core/bitArray.js  //////////

  sjcl.bitArray = {
    bitSlice: function (a, bstart, bend) {
      a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);
      return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);
    },

    extract: function(a, bstart, blength) {
      var x, sh = Math.floor((-bstart-blength) & 31);
      if ((bstart + blength - 1 ^ bstart) & -32) {
        x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);
      } else {
        x = a[bstart/32|0] >>> sh;
      }
      return x & ((1<<blength) - 1);
    },

    concat: function (a1, a2) {
      if (a1.length === 0 || a2.length === 0) {
        return a1.concat(a2);
      }

      var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);
      if (shift === 32) {
        return a1.concat(a2);
      } else {
        return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));
      }
    },

    bitLength: function (a) {
      var l = a.length, x;
      if (l === 0) { return 0; }
      x = a[l - 1];
      return (l-1) * 32 + sjcl.bitArray.getPartial(x);
    },

    clamp: function (a, len) {
      if (a.length * 32 < len) { return a; }
      a = a.slice(0, Math.ceil(len / 32));
      var l = a.length;
      len = len & 31;
      if (l > 0 && len) {
        a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);
      }
      return a;
    },

    partial: function (len, x, _end) {
      if (len === 32) { return x; }
      return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;
    },

    getPartial: function (x) {
      return Math.round(x/0x10000000000) || 32;
    },

    _shiftRight: function (a, shift, carry, out) {
      var i, last2=0, shift2;
      if (out === undefined) { out = []; }

      for (; shift >= 32; shift -= 32) {
        out.push(carry);
        carry = 0;
      }
      if (shift === 0) {
        return out.concat(a);
      }

      for (i=0; i<a.length; i++) {
        out.push(carry | a[i]>>>shift);
        carry = a[i] << (32-shift);
      }
      last2 = a.length ? a[a.length-1] : 0;
      shift2 = sjcl.bitArray.getPartial(last2);
      out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));
      return out;
    },

    _xor4: function(x,y) {
      return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];
    }
  };




  //////////  core/codecArrayBuffer.js  //////////

  if (typeof(ArrayBuffer) === 'undefined') {
    (function(globals){
        "use strict";
        globals.ArrayBuffer = function(){};
        globals.DataView = function(){};
    }(this));
  }

  sjcl.codec.arrayBuffer = {
    fromBits: function (arr, padding, padding_count) {
      var out, i, ol, tmp, smallest;
      padding = padding==undefined  ? true : padding
      padding_count = padding_count || 8

      if (arr.length === 0) {
        return new ArrayBuffer(0);
      }

      ol = sjcl.bitArray.bitLength(arr)/8;

      if ( sjcl.bitArray.bitLength(arr)%8 !== 0 ) {
        throw new sjcl.exception.invalid("Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly")
      }

      if (padding && ol%padding_count !== 0){
        ol += padding_count - (ol%padding_count);
      }

      tmp = new DataView(new ArrayBuffer(arr.length*4));
      for (i=0; i<arr.length; i++) {
        tmp.setUint32(i*4, (arr[i]<<32));
      }

      out = new DataView(new ArrayBuffer(ol));

      if (out.byteLength === tmp.byteLength){
        return tmp.buffer;
      }

      smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;
      for(i=0; i<smallest; i++){
        out.setUint8(i,tmp.getUint8(i));
      }


      return out.buffer
    }
  };




  //////////  core/codecString.js  //////////

  sjcl.codec.utf8String = {
    toBits: function (str) {
      str = unescape(encodeURIComponent(str));
      var out = [], i, tmp=0;
      for (i=0; i<str.length; i++) {
        tmp = tmp << 8 | str.charCodeAt(i);
        if ((i&3) === 3) {
          out.push(tmp);
          tmp = 0;
        }
      }
      if (i&3) {
        out.push(sjcl.bitArray.partial(8*(i&3), tmp));
      }
      return out;
    }
  };




  //////////  core/sha256.js  //////////

  sjcl.hash.sha256 = function (hash) {
    if (!this._key[0]) { this._precompute(); }
    if (hash) {
      this._h = hash._h.slice(0);
      this._buffer = hash._buffer.slice(0);
      this._length = hash._length;
    } else {
      this.reset();
    }
  };

  sjcl.hash.sha256.hash = function (data) {
    return (new sjcl.hash.sha256()).update(data).finalize();
  };

  sjcl.hash.sha256.prototype = {
    blockSize: 512,

    reset:function () {
      this._h = this._init.slice(0);
      this._buffer = [];
      this._length = 0;
      return this;
    },

    update: function (data) {
      if (typeof data === "string") {
        data = sjcl.codec.utf8String.toBits(data);
      }
      var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
          ol = this._length,
          nl = this._length = ol + sjcl.bitArray.bitLength(data);
      for (i = 512+ol & -512; i <= nl; i+= 512) {
        this._block(b.splice(0,16));
      }
      return this;
    },

    finalize:function () {
      var i, b = this._buffer, h = this._h;

      b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);

      for (i = b.length + 2; i & 15; i++) {
        b.push(0);
      }

      b.push(Math.floor(this._length / 0x100000000));
      b.push(this._length | 0);

      while (b.length) {
        this._block(b.splice(0,16));
      }

      this.reset();
      return h;
    },

    _init:[],

    _key:[],

    _precompute: function () {
      var i = 0, prime = 2, factor;

      function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }

      outer: for (; i<64; prime++) {
        for (factor=2; factor*factor <= prime; factor++) {
          if (prime % factor === 0) {
            continue outer;
          }
        }

        if (i<8) {
          this._init[i] = frac(Math.pow(prime, 1/2));
        }
        this._key[i] = frac(Math.pow(prime, 1/3));
        i++;
      }
    },

    _block:function (words) {
      var i, tmp, a, b,
        w = words.slice(0),
        h = this._h,
        k = this._key,
        h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],
        h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];

        for (i=0; i<64; i++) {
        if (i<16) {
          tmp = w[i];
        } else {
          a   = w[(i+1 ) & 15];
          b   = w[(i+14) & 15];
          tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) +
                           (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +
                           w[i&15] + w[(i+9) & 15]) | 0;
        }

        tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]);

        h7 = h6; h6 = h5; h5 = h4;
        h4 = h3 + tmp | 0;
        h3 = h2; h2 = h1; h1 = h0;

        h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;
      }

      h[0] = h[0]+h0 | 0;
      h[1] = h[1]+h1 | 0;
      h[2] = h[2]+h2 | 0;
      h[3] = h[3]+h3 | 0;
      h[4] = h[4]+h4 | 0;
      h[5] = h[5]+h5 | 0;
      h[6] = h[6]+h6 | 0;
      h[7] = h[7]+h7 | 0;
    }
  };




  //////////  core/aes.js  //////////

  sjcl.cipher.aes = function (key) {
    if (!this._tables[0][0][0]) {
      this._precompute();
    }

    var i, j, tmp,
      encKey, decKey,
      sbox = this._tables[0][4], decTable = this._tables[1],
      keyLen = key.length, rcon = 1;

    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
      throw new sjcl.exception.invalid("invalid aes key size");
    }

    this._key = [encKey = key.slice(0), decKey = []];

    for (i = keyLen; i < 4 * keyLen + 28; i++) {
      tmp = encKey[i-1];

      if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {
        tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];

        if (i%keyLen === 0) {
          tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;
          rcon = rcon<<1 ^ (rcon>>7)*283;
        }
      }

      encKey[i] = encKey[i-keyLen] ^ tmp;
    }

    for (j = 0; i; j++, i--) {
      tmp = encKey[j&3 ? i : i - 4];
      if (i<=4 || j<4) {
        decKey[j] = tmp;
      } else {
        decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^
                    decTable[1][sbox[tmp>>16  & 255]] ^
                    decTable[2][sbox[tmp>>8   & 255]] ^
                    decTable[3][sbox[tmp      & 255]];
      }
    }
  };

  sjcl.cipher.aes.prototype = {

    encrypt:function (data) { return this._crypt(data,0); },

    _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],

    _precompute: function () {
     var encTable = this._tables[0], decTable = this._tables[1],
         sbox = encTable[4], sboxInv = decTable[4],
         i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;

     for (i = 0; i < 256; i++) {
       th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;
     }

     for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
       s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;
       s = s>>8 ^ s&255 ^ 99;
       sbox[x] = s;
       sboxInv[s] = x;

       x8 = d[x4 = d[x2 = d[x]]];
       tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;
       tEnc = d[s]*0x101 ^ s*0x1010100;

       for (i = 0; i < 4; i++) {
         encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;
         decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;
       }
     }

     for (i = 0; i < 5; i++) {
       encTable[i] = encTable[i].slice(0);
       decTable[i] = decTable[i].slice(0);
     }
    },

    _crypt:function (input, dir) {
      if (input.length !== 4) {
        throw new sjcl.exception.invalid("invalid aes block size");
      }

      var key = this._key[dir],
          a = input[0]           ^ key[0],
          b = input[dir ? 3 : 1] ^ key[1],
          c = input[2]           ^ key[2],
          d = input[dir ? 1 : 3] ^ key[3],
          a2, b2, c2,

          nInnerRounds = key.length/4 - 2,
          i,
          kIndex = 4,
          out = [0,0,0,0],
          table = this._tables[dir],

          t0    = table[0],
          t1    = table[1],
          t2    = table[2],
          t3    = table[3],
          sbox  = table[4];

      for (i = 0; i < nInnerRounds; i++) {
        a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];
        b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
        c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
        d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
        kIndex += 4;
        a=a2; b=b2; c=c2;
      }

      for (i = 0; i < 4; i++) {
        out[dir ? 3&-i : i] =
          sbox[a>>>24      ]<<24 ^
          sbox[b>>16  & 255]<<16 ^
          sbox[c>>8   & 255]<<8  ^
          sbox[d      & 255]     ^
          key[kIndex++];
        a2=a; a=b; b=c; c=d; d=a2;
      }

      return out;
    }
  };




  //////////  core/ccm.js  //////////

  sjcl.mode.ccm = {
    name: "ccm",

    encrypt: function(prf, plaintext, iv, adata, tlen) {
      var L, out = plaintext.slice(0), tag, w=sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;
      tlen = tlen || 64;
      adata = adata || [];

      if (ivl < 7) {
        throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
      }

      for (L=2; L<4 && ol >>> 8*L; L++) {}
      if (L < 15 - ivl) { L = 15-ivl; }
      iv = w.clamp(iv,8*(15-L));

      tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);

      out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);

      return w.concat(out.data, out.tag);
    },

    _macAdditionalData: function (prf, adata, iv, tlen, ol, L) {
      var mac, tmp, i, macData = [], w=sjcl.bitArray, xor = w._xor4;

      mac = [w.partial(8, (adata.length ? 1<<6 : 0) | (tlen-2) << 2 | L-1)];

      mac = w.concat(mac, iv);
      mac[3] |= ol;
      mac = prf.encrypt(mac);

      if (adata.length) {
        tmp = w.bitLength(adata)/8;
        if (tmp <= 0xFEFF) {
          macData = [w.partial(16, tmp)];
        } else if (tmp <= 0xFFFFFFFF) {
          macData = w.concat([w.partial(16,0xFFFE)], [tmp]);
        }

        macData = w.concat(macData, adata);
        for (i=0; i<macData.length; i += 4) {
          mac = prf.encrypt(xor(mac, macData.slice(i,i+4).concat([0,0,0])));
        }
      }

      return mac;
    },

    _computeTag: function(prf, plaintext, iv, adata, tlen, L) {
      var mac, i, w=sjcl.bitArray, xor = w._xor4;

      tlen /= 8;

      if (tlen % 2 || tlen < 4 || tlen > 16) {
        throw new sjcl.exception.invalid("ccm: invalid tag length");
      }

      if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {
        throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
      }

      mac = sjcl.mode.ccm._macAdditionalData(prf, adata, iv, tlen, w.bitLength(plaintext)/8, L);

      for (i=0; i<plaintext.length; i+=4) {
        mac = prf.encrypt(xor(mac, plaintext.slice(i,i+4).concat([0,0,0])));
      }

      return w.clamp(mac, tlen * 8);
    },

    _ctrMode: function(prf, data, iv, tag, tlen, L) {
      var enc, i, w=sjcl.bitArray, xor = w._xor4, ctr, l = data.length, bl=w.bitLength(data), n = l/50, p = n;

      ctr = w.concat([w.partial(8,L-1)],iv).concat([0,0,0]).slice(0,4);

      tag = w.bitSlice(xor(tag,prf.encrypt(ctr)), 0, tlen);

      if (!l) { return {tag:tag, data:[]}; }

      for (i=0; i<l; i+=4) {
        if (i > n) {
          n += p;
        }
        ctr[3]++;
        enc = prf.encrypt(ctr);
        data[i]   ^= enc[0];
        data[i+1] ^= enc[1];
        data[i+2] ^= enc[2];
        data[i+3] ^= enc[3];
      }
      return { tag:tag, data:w.clamp(data,bl) };
    }
  };
</script>
<script>
  makeDemoNote();
</script>
</body>
</html>